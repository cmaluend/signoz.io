---
date: 2026-02-05
id: opentelemetry-ruby
title: Send Metrics from Ruby application
description: Learn how to send metrics from Ruby applications (Rails, Sinatra, Sidekiq) to SigNoz using OpenTelemetry

doc_type: howto
---

This guide shows you how to send metrics from your Ruby application (Rails, Sinatra, Sidekiq) to SigNoz using OpenTelemetry.

<Admonition type="warning">
The OpenTelemetry Ruby Metrics SDK is currently in **Development** status (not yet stable). APIs may change in future releases. While it supports synchronous instruments (Counter, UpDownCounter, Histogram) and observable instruments, some features like cumulative temporality, metrics views, and exemplars are not yet implemented. See the <a href="https://github.com/open-telemetry/opentelemetry-ruby/tree/main/metrics_sdk" target="_blank" rel="noopener noreferrer nofollow">official SDK documentation</a> for current status.
</Admonition>

<KeyPointCallout title="Using self-hosted SigNoz?" defaultCollapsed={true}>
    Most steps are identical. To adapt this guide, update the endpoint and remove the ingestion key header as shown in [Cloud → Self-Hosted](https://signoz.io/docs/ingestion/cloud-vs-self-hosted/#cloud-to-self-hosted).
</KeyPointCallout>

## Prerequisites

- Ruby 3.1 or later
- Bundler installed
- A SigNoz Cloud account or self-hosted SigNoz instance

## Send metrics to SigNoz

<Tabs entityName="deployment">
<TabItem value="vm" label="VM" default>
<KeyPointCallout title="What classifies as VM?" defaultCollapsed={true}>
    A VM is a virtual computer that runs on physical hardware. This includes:
    - **Cloud VMs**: AWS EC2, Google Compute Engine, Azure VMs, DigitalOcean Droplets
    - **On-premise VMs**: VMware, VirtualBox, Hyper-V, KVM
    - **Bare metal servers**: Physical servers running Linux/Unix directly

    Use this section if you're deploying your Ruby application directly on a server or VM without containerization.
</KeyPointCallout>

### Step 1. Set environment variables
Set the following environment variables to configure the OpenTelemetry exporter:
```bash
export OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443"
export OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>"
export OTEL_SERVICE_NAME="<service-name>"
export OTEL_METRICS_EXPORTER="none"
export OTEL_METRIC_EXPORT_INTERVAL="60000"
```
Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`).
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>

<TabItem value="k8s" label="Kubernetes">
### Step 1. Set environment variables
Add these environment variables to your deployment manifest:
```yaml
env:
- name: OTEL_EXPORTER_OTLP_ENDPOINT
  value: 'https://ingest.<region>.signoz.cloud:443'
- name: OTEL_EXPORTER_OTLP_HEADERS
  value: 'signoz-ingestion-key=<your-ingestion-key>'
- name: OTEL_SERVICE_NAME
  value: '<service-name>'
- name: OTEL_METRICS_EXPORTER
  value: 'none'
- name: OTEL_METRIC_EXPORT_INTERVAL
  value: '60000'
```
Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`).
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>

<TabItem value="windows" label="Windows">
### Step 1. Set environment variables (PowerShell)
```powershell
$env:OTEL_EXPORTER_OTLP_ENDPOINT = "https://ingest.<region>.signoz.cloud:443"
$env:OTEL_EXPORTER_OTLP_HEADERS = "signoz-ingestion-key=<your-ingestion-key>"
$env:OTEL_SERVICE_NAME = "<service-name>"
$env:OTEL_METRICS_EXPORTER = "none"
$env:OTEL_METRIC_EXPORT_INTERVAL = "60000"
```
Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint).
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service.
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>

<TabItem value="docker" label="Docker">
### Step 1. Set environment variables in Dockerfile
Add environment variables to your Dockerfile:
```dockerfile:Dockerfile
# ... build stages ...

# Set OpenTelemetry environment variables
ENV OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443"
ENV OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>"
ENV OTEL_SERVICE_NAME="<service-name>"
ENV OTEL_METRICS_EXPORTER="none"
ENV OTEL_METRIC_EXPORT_INTERVAL="60000"

CMD ["ruby", "app.rb"]
```

Or pass them at runtime using `docker run`:
```bash
docker run -e OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443" \
    -e OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>" \
    -e OTEL_SERVICE_NAME="<service-name>" \
    -e OTEL_METRICS_EXPORTER="none" \
    -e OTEL_METRIC_EXPORT_INTERVAL="60000" \
    your-image:latest
```

Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`).
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>
</Tabs>

<KeyPointCallout title="Why set OTEL_METRICS_EXPORTER to 'none'?" defaultCollapsed={true}>
Setting `OTEL_METRICS_EXPORTER` to `none` prevents the SDK from auto-configuring a default exporter. This allows you to manually configure the OTLP metrics exporter with your specific settings in Step 3, giving you full control over the export configuration.
</KeyPointCallout>

### Step 2. Install OpenTelemetry packages

Add the following gems to your `Gemfile`:

```ruby:Gemfile
gem 'opentelemetry-sdk'
gem 'opentelemetry-metrics-api'
gem 'opentelemetry-metrics-sdk'
gem 'opentelemetry-exporter-otlp-metrics'
```

Run bundle install:

```bash
bundle install
```

### Step 3. Configure OpenTelemetry SDK

Create an initializer file to configure the SDK and metrics exporter:

```ruby:config/initializers/opentelemetry.rb
require 'opentelemetry/sdk'
require 'opentelemetry-metrics-sdk'
require 'opentelemetry/exporter/otlp_metrics'

# Configure the SDK
OpenTelemetry::SDK.configure do |c|
  c.service_name = ENV['OTEL_SERVICE_NAME'] || 'my-ruby-service'
end

# Create OTLP metrics exporter
otlp_metric_exporter = OpenTelemetry::Exporter::OTLP::Metrics::MetricsExporter.new

# Add the exporter to the meter provider
OpenTelemetry.meter_provider.add_metric_reader(otlp_metric_exporter)
```

The exporter automatically reads `OTEL_EXPORTER_OTLP_ENDPOINT` and `OTEL_EXPORTER_OTLP_HEADERS` from your environment variables.

### Step 4. Add custom metrics

Add custom metrics to your application using `OpenTelemetry.meter_provider.meter`:

```ruby:app.rb
require_relative 'config/initializers/opentelemetry'

# Get a meter - MeterProvider is configured by the initializer
meter = OpenTelemetry.meter_provider.meter('my.meter.name')

# Create a counter instrument
request_counter = meter.create_counter(
  'requests.total',
  unit: '1',
  description: 'Total number of requests'
)

def handle_request(endpoint)
  # Record the metric with attributes
  request_counter.add(1, attributes: { 'endpoint' => endpoint })
  # ... handle the request ...
end
```

<Admonition type="info">
This example shows a Counter, which only increases. OpenTelemetry supports other metric types like UpDownCounter, Histogram, and Observable Gauge. See [Custom Metrics Examples](#custom-metrics-examples) for complete examples of each type.
</Admonition>

### Step 5. Run your application

Run your application normally:

```bash
ruby app.rb
```

For Rails applications:

```bash
rails server
```

<Admonition type="warning">
Before your application exits, ensure metrics are exported by calling `pull` on all metric readers and shutting down the meter provider:

```ruby
at_exit do
  OpenTelemetry.meter_provider.metric_readers.each(&:pull)
  OpenTelemetry.meter_provider.shutdown
end
```
</Admonition>

## Validate

Once you have configured your application to start sending metrics to SigNoz, you can start visualizing the metrics in the [metrics explorer](https://signoz.io/docs/metrics-management/metrics-explorer/).

<Admonition type="info">
Want more metrics? For system-level metrics like CPU, memory, and thread counts, see [Runtime Metrics](#runtime-metrics).
</Admonition>

<details>
<ToggleHeading>
## Custom Metrics Examples
</ToggleHeading>

OpenTelemetry supports six metric instrument types. Here's a complete example demonstrating all of them:

### Synchronous Instruments

Synchronous instruments are called inline with your application code.

**Counter** - A value that only increases (e.g., total requests, bytes sent):

```ruby
counter = meter.create_counter(
  'requests.total',
  unit: '1',
  description: 'Total number of requests'
)

# Record a value
counter.add(1, attributes: { 'endpoint' => '/api/users' })
```

**UpDownCounter** - A value that can increase or decrease (e.g., active connections, queue size):

```ruby
updown_counter = meter.create_up_down_counter(
  'connections.active',
  unit: '1',
  description: 'Number of active connections'
)

# Increment
updown_counter.add(1)

# Decrement
updown_counter.add(-1)
```

**Histogram** - A distribution of values (e.g., request latency, response sizes):

```ruby
histogram = meter.create_histogram(
  'request.duration',
  unit: 'ms',
  description: 'Request duration in milliseconds'
)

# Record a value
histogram.record(45.5, attributes: { 'endpoint' => '/api/users' })
```

### Asynchronous Instruments

Asynchronous instruments use callback procs that are invoked during metric collection. The callback must **return a numeric value** that will be recorded.

<Admonition type="info">
Unlike Python or Node.js, Ruby's OpenTelemetry Metrics SDK uses a simpler callback model where the proc returns a value directly instead of using an observer object. Attributes can be set using `add_attributes` on the instrument after creation.
</Admonition>

**ObservableCounter** - Observes a monotonically increasing value (e.g., CPU time, page faults):

```ruby
cpu_callback = proc do
  # Return the CPU time in seconds
  Process.times.utime + Process.times.stime
end

cpu_counter = meter.create_observable_counter(
  'system.cpu.time',
  callback: cpu_callback,
  unit: 's',
  description: 'CPU time'
)
```

**ObservableUpDownCounter** - Observes a value that can go up or down (e.g., memory usage, thread count):

```ruby
thread_callback = proc do
  # Return the current thread count
  Thread.list.count
end

meter.create_observable_up_down_counter(
  'process.threads.count',
  callback: thread_callback,
  unit: '1',
  description: 'Current thread count'
)
```

**ObservableGauge** - Observes a point-in-time value (e.g., temperature, current memory usage):

```ruby
memory_callback = proc do
  # Return resident set size in bytes
  memory_kb = `ps -o rss= -p #{Process.pid}`.to_i
  memory_kb * 1024
end

meter.create_observable_gauge(
  'process.memory.usage',
  callback: memory_callback,
  unit: 'By',
  description: 'Current memory usage in bytes'
)
```

</details>

<details>
<ToggleHeading>
## Runtime Metrics
</ToggleHeading>

Ruby does not have a built-in runtime metrics package like Python or Node.js. However, you can collect system and process metrics using observable instruments.

### Create a Runtime Metrics Helper

Create a helper module to collect common runtime metrics:

```ruby:lib/runtime_metrics.rb
module RuntimeMetrics
  def self.setup(meter)
    # Memory usage (returns bytes)
    memory_callback = proc do
      memory_kb = `ps -o rss= -p #{Process.pid}`.to_i
      memory_kb * 1024
    end
    meter.create_observable_gauge(
      'process.memory.usage',
      callback: memory_callback,
      unit: 'By',
      description: 'Process memory usage in bytes'
    )

    # Thread count
    thread_callback = proc { Thread.list.count }
    meter.create_observable_up_down_counter(
      'process.threads.count',
      callback: thread_callback,
      unit: '1',
      description: 'Number of threads in the process'
    )

    # CPU time (user mode)
    cpu_user_callback = proc { Process.times.utime }
    meter.create_observable_counter(
      'process.cpu.time.user',
      callback: cpu_user_callback,
      unit: 's',
      description: 'Process CPU time in user mode'
    )

    # CPU time (system mode)
    cpu_system_callback = proc { Process.times.stime }
    meter.create_observable_counter(
      'process.cpu.time.system',
      callback: cpu_system_callback,
      unit: 's',
      description: 'Process CPU time in system mode'
    )

    # GC stats (Ruby specific)
    gc_count_callback = proc { GC.count }
    meter.create_observable_counter(
      'ruby.gc.count',
      callback: gc_count_callback,
      unit: '1',
      description: 'Number of garbage collections'
    )

    heap_callback = proc { GC.stat[:heap_live_slots] }
    meter.create_observable_gauge(
      'ruby.gc.heap_live_slots',
      callback: heap_callback,
      unit: '1',
      description: 'Number of live objects in the heap'
    )
  end
end
```

### Usage

Enable runtime metrics in your initializer:

```ruby:config/initializers/opentelemetry.rb
require 'opentelemetry/sdk'
require 'opentelemetry-metrics-sdk'
require 'opentelemetry/exporter/otlp_metrics'
require_relative '../../lib/runtime_metrics'

OpenTelemetry::SDK.configure do |c|
  c.service_name = ENV['OTEL_SERVICE_NAME'] || 'my-ruby-service'
end

otlp_metric_exporter = OpenTelemetry::Exporter::OTLP::Metrics::MetricsExporter.new
OpenTelemetry.meter_provider.add_metric_reader(otlp_metric_exporter)

# Enable runtime metrics
meter = OpenTelemetry.meter_provider.meter('runtime')
RuntimeMetrics.setup(meter)
```

### Exported Metrics

The runtime metrics helper exports the following metrics:

**Process Metrics:**
- `process.memory.usage` - Process memory usage in bytes (gauge)
- `process.threads.count` - Number of threads in the process (up-down counter)
- `process.cpu.time.user` - Process CPU time in user mode (counter)
- `process.cpu.time.system` - Process CPU time in system mode (counter)

**Ruby Runtime Metrics:**
- `ruby.gc.count` - Total number of garbage collections (counter)
- `ruby.gc.heap_live_slots` - Number of live objects in the heap (gauge)

</details>

<details>
<ToggleHeading>
## Troubleshooting
</ToggleHeading>

### Metrics not appearing?

1. **Check Environment Variables**: Ensure `OTEL_EXPORTER_OTLP_ENDPOINT` is set correctly:
    - For gRPC: `https://ingest.<region>.signoz.cloud:443`
    - For HTTP: `https://ingest.<region>.signoz.cloud:443/v1/metrics`

2. **Check Exporter Protocol**: The Ruby OTLP metrics exporter uses HTTP by default. Ensure your endpoint matches.

3. **Verify Metrics are Pulled**: The Ruby SDK uses a pull-based export model. Ensure you call `pull` before shutdown:
    ```ruby
    OpenTelemetry.meter_provider.metric_readers.each(&:pull)
    OpenTelemetry.meter_provider.shutdown
    ```

4. **Enable Debug Logging**: Check for errors in your application logs. You can enable verbose output:
    ```ruby
    OpenTelemetry.logger = Logger.new(STDOUT)
    OpenTelemetry.logger.level = Logger::DEBUG
    ```

5. **Verify Package Installation**: Ensure all required gems are installed:
    ```bash
    bundle list | grep opentelemetry
    ```

### Authentication errors

If you see errors like "Unauthorized" or "403 Forbidden":
- Verify your ingestion key is correct in `OTEL_EXPORTER_OTLP_HEADERS`
- Ensure the header format is exactly: `signoz-ingestion-key=<your-key>` (no extra spaces)
- Check that your ingestion key is active in the SigNoz Cloud dashboard

### "Connection Refused" errors

- If running locally and sending to SigNoz Cloud, check your internet connection and firewall.
- If sending to a self-hosted collector, ensure the collector is running and listening on port 4317 (gRPC) or 4318 (HTTP).

### SSL/TLS errors

If you encounter SSL certificate errors:
- Ensure you're using `https://` in the endpoint URL
- For self-hosted setups with self-signed certificates, you may need to configure the exporter to trust your CA

### Metrics not exported on application exit

Ruby applications may exit before metrics are exported. Add a shutdown hook:

```ruby
at_exit do
  OpenTelemetry.meter_provider.metric_readers.each(&:pull)
  OpenTelemetry.meter_provider.shutdown
end
```

</details>

<details>
<ToggleHeading>
## Setup OpenTelemetry Collector (Optional)
</ToggleHeading>

### What is the OpenTelemetry Collector?

Think of the OTel Collector as a middleman between your app and SigNoz. Instead of your application sending data directly to SigNoz, it sends everything to the Collector first, which then forwards it along.

### Why use it?

- **Cleaning up data** — Filter out noisy metrics you don't care about, or remove sensitive info before it leaves your servers.
- **Keeping your app lightweight** — Let the Collector handle batching, retries, and compression instead of your application code.
- **Adding context automatically** — The Collector can tag your data with useful info like which Kubernetes pod or cloud region it came from.
- **Future flexibility** — Want to send data to multiple backends later? The Collector makes that easy without changing your app.

See [Switch from direct export to Collector](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/switch-to-collector/) for step-by-step instructions to convert your setup.

For more details, see [Why use the OpenTelemetry Collector?](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/why-to-use-collector/) and the [Collector configuration guide](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/configuration/).

</details>

## Next Steps

- [Create Dashboards](https://signoz.io/docs/userguide/manage-dashboards/) to visualize your metrics.
- [Set up Alerts](https://signoz.io/docs/setup-alerts-notification/) on your metrics.
- Instrument your Ruby application with [traces](https://signoz.io/docs/instrumentation/opentelemetry-ruby/) for complete observability.
