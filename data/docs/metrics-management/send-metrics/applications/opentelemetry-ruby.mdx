---
date: 2026-02-06
id: opentelemetry-ruby
title: Send Metrics from Ruby Application Using OpenTelemetry
description: Learn how to send metrics from Ruby applications (Rails, Sinatra, Sidekiq) to SigNoz using OpenTelemetry

doc_type: howto
---

This guide shows you how to send metrics from your Ruby application (Rails, Sinatra, Sidekiq) to SigNoz using OpenTelemetry.

<Admonition type="warning">
The OpenTelemetry Ruby Metrics SDK is currently in **Development** status (not yet stable). APIs may change in future releases. While it supports synchronous instruments (Counter, UpDownCounter, Histogram) and observable instruments, some features like cumulative temporality, metrics views, and exemplars are not yet implemented. See the <a href="https://github.com/open-telemetry/opentelemetry-ruby/tree/main/metrics_sdk" target="_blank" rel="noopener noreferrer nofollow">official SDK documentation</a> for current status.
</Admonition>

<KeyPointCallout title="Using self-hosted SigNoz?" defaultCollapsed={true}>
    Most steps are identical. To adapt this guide, update the endpoint and remove the ingestion key header as shown in [Cloud → Self-Hosted](https://signoz.io/docs/ingestion/cloud-vs-self-hosted/#cloud-to-self-hosted).
</KeyPointCallout>

## Prerequisites

- Ruby 3.1 or later
- Bundler installed
- A SigNoz Cloud account or self-hosted SigNoz instance

## Send metrics to SigNoz

<Tabs entityName="deployment">
<TabItem value="vm" label="VM" default>
<KeyPointCallout title="What classifies as VM?" defaultCollapsed={true}>
    A VM is a virtual computer that runs on physical hardware. This includes:
    - **Cloud VMs**: AWS EC2, Google Compute Engine, Azure VMs, DigitalOcean Droplets
    - **On-premise VMs**: VMware, VirtualBox, Hyper-V, KVM
    - **Bare metal servers**: Physical servers running Linux/Unix directly

    Use this section if you're deploying your Ruby application directly on a server or VM without containerization.
</KeyPointCallout>

### Step 1. Set environment variables
Set the following environment variables to configure the OpenTelemetry exporter:
```bash
export OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443"
export OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>"
export OTEL_SERVICE_NAME="<service-name>"
export OTEL_TRACES_EXPORTER="none"
export OTEL_LOGS_EXPORTER="none"
export OTEL_METRIC_EXPORT_INTERVAL="60000"
```
Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`).
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>

<TabItem value="k8s" label="Kubernetes">
### Step 1. Set environment variables
Add these environment variables to your deployment manifest:
```yaml
env:
- name: OTEL_EXPORTER_OTLP_ENDPOINT
  value: 'https://ingest.<region>.signoz.cloud:443'
- name: OTEL_EXPORTER_OTLP_HEADERS
  value: 'signoz-ingestion-key=<your-ingestion-key>'
- name: OTEL_SERVICE_NAME
  value: '<service-name>'
- name: OTEL_TRACES_EXPORTER
  value: 'none'
- name: OTEL_LOGS_EXPORTER
  value: 'none'
- name: OTEL_METRIC_EXPORT_INTERVAL
  value: '60000'
```
Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`).
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>

<TabItem value="docker" label="Docker">
### Step 1. Set environment variables in Dockerfile
Add environment variables to your Dockerfile:
```dockerfile:Dockerfile
# ... build stages ...

# Set OpenTelemetry environment variables
ENV OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443"
ENV OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>"
ENV OTEL_SERVICE_NAME="<service-name>"
ENV OTEL_TRACES_EXPORTER="none"
ENV OTEL_LOGS_EXPORTER="none"
ENV OTEL_METRIC_EXPORT_INTERVAL="60000"

CMD ["ruby", "app.rb"]
```

Or pass them at runtime using `docker run`:
```bash
docker run -e OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443" \
    -e OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>" \
    -e OTEL_SERVICE_NAME="<service-name>" \
    -e OTEL_TRACES_EXPORTER="none" \
    -e OTEL_LOGS_EXPORTER="none" \
    -e OTEL_METRIC_EXPORT_INTERVAL="60000" \
    your-image:latest
```

Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`).
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>

<TabItem value="windows" label="Windows">
### Step 1. Set environment variables (PowerShell)
```powershell
$env:OTEL_EXPORTER_OTLP_ENDPOINT = "https://ingest.<region>.signoz.cloud:443"
$env:OTEL_EXPORTER_OTLP_HEADERS = "signoz-ingestion-key=<your-ingestion-key>"
$env:OTEL_SERVICE_NAME = "<service-name>"
$env:OTEL_TRACES_EXPORTER = "none"
$env:OTEL_LOGS_EXPORTER = "none"
$env:OTEL_METRIC_EXPORT_INTERVAL = "60000"
```
Verify these values:
- `<region>`: Your [SigNoz Cloud region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint).
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service-name>`: A descriptive name for your service.
- `OTEL_METRIC_EXPORT_INTERVAL`: How often to export metrics in milliseconds (default: 60000 for 60 seconds).

</TabItem>
</Tabs>

<KeyPointCallout title="Why explicitly disable traces and logs?" defaultCollapsed={true}>
Since the OpenTelemetry Ruby SDK enables traces and logs export by default, these would be sent to SigNoz even though this guide only covers metrics. For apps handling many requests, this can generate significant volume and costs.

Setting `OTEL_TRACES_EXPORTER` and `OTEL_LOGS_EXPORTER` to `none` disables traces and logs while keeping metrics working as expected. If you want traces or logs later, you can change them to `otlp` or remove these variables altogether.
</KeyPointCallout>

### Step 2. Install OpenTelemetry packages

Add the following gems to your `Gemfile`:

```ruby:Gemfile
gem 'opentelemetry-sdk'
gem 'opentelemetry-metrics-api'
gem 'opentelemetry-metrics-sdk'
gem 'opentelemetry-exporter-otlp-metrics'
```

Run bundle install:

```bash
bundle install
```

### Step 3. Configure OpenTelemetry SDK

Create an initializer file to configure the SDK:

```ruby:config/initializers/opentelemetry.rb
require 'opentelemetry/sdk'
require 'opentelemetry-metrics-sdk'
require 'opentelemetry/exporter/otlp_metrics'

# Configure the SDK
OpenTelemetry::SDK.configure do |c|
  c.service_name = ENV['OTEL_SERVICE_NAME'] || 'my-ruby-service'
end
```

The SDK automatically configures the OTLP metrics exporter using `OTEL_EXPORTER_OTLP_ENDPOINT` and `OTEL_EXPORTER_OTLP_HEADERS` from your environment variables. Metrics are exported periodically based on `OTEL_METRIC_EXPORT_INTERVAL`.

### Step 4. Add custom metrics

Add custom metrics to your application using `OpenTelemetry.meter_provider.meter`:

```ruby:app.rb
require_relative 'config/initializers/opentelemetry'

# Get a meter - MeterProvider is configured by the initializer
METER = OpenTelemetry.meter_provider.meter('my.meter.name')

# Create a counter instrument
REQUEST_COUNTER = METER.create_counter(
  'requests.total',
  unit: '1',
  description: 'Total number of requests'
)

def handle_request(endpoint)
  # Record the metric with attributes
  REQUEST_COUNTER.add(1, attributes: { 'endpoint' => endpoint })
  # ... handle the request ...
end
```

<Admonition type="info">
This example shows a Counter, which only increases. OpenTelemetry supports other metric types like UpDownCounter, Histogram, and Observable Gauge. See [Custom Metrics Examples](#custom-metrics-examples) for complete examples of each type.
</Admonition>

### Step 5. Run your application

Run your application normally:

```bash
ruby app.rb
```

For Rails applications:

```bash
rails server
```

<Admonition type="warning">
Before your application exits, ensure any remaining metrics are flushed by shutting down the meter provider:

```ruby
at_exit do
  OpenTelemetry.meter_provider.shutdown
end
```
</Admonition>

## Validate

Once you have configured your application to start sending metrics to SigNoz, you can start visualizing the metrics in the [metrics explorer](https://signoz.io/docs/metrics-management/metrics-explorer/).

<Admonition type="info">
Want more metrics? For system-level metrics like CPU, memory, and thread counts, see [Runtime Metrics](#runtime-metrics).
</Admonition>

<details>
<ToggleHeading>
## Custom Metrics Examples
</ToggleHeading>

OpenTelemetry supports six metric instrument types. Here's a complete example demonstrating all of them:

### Synchronous Instruments

Synchronous instruments are called inline with your application code.

**Counter** - A value that only increases (e.g., total requests, bytes sent):

```ruby
counter = meter.create_counter(
  'requests.total',
  unit: '1',
  description: 'Total number of requests'
)

# Record a value
counter.add(1, attributes: { 'endpoint' => '/api/users' })
```

**UpDownCounter** - A value that can increase or decrease (e.g., active connections, queue size):

```ruby
updown_counter = meter.create_up_down_counter(
  'connections.active',
  unit: '1',
  description: 'Number of active connections'
)

# Increment
updown_counter.add(1)

# Decrement
updown_counter.add(-1)
```

**Histogram** - A distribution of values (e.g., request latency, response sizes):

```ruby
histogram = meter.create_histogram(
  'request.duration',
  unit: 'ms',
  description: 'Request duration in milliseconds'
)

# Record a value
histogram.record(45.5, attributes: { 'endpoint' => '/api/users' })
```

### Asynchronous Instruments

Asynchronous instruments use callback procs that are invoked during metric collection. The callback must **return a numeric value** that will be recorded.

<Admonition type="info">
In some other OpenTelemetry SDKs, observable callbacks receive an observer object and call `observer.observe(value, attributes)` to record values. Ruby's SDK uses a simpler model: the callback proc returns a numeric value directly, and the SDK records it automatically.
</Admonition>

**ObservableCounter** - Observes a monotonically increasing value (e.g., CPU time, page faults):

```ruby
cpu_callback = proc do
  # Return the CPU time in seconds
  Process.times.utime + Process.times.stime
end

cpu_counter = meter.create_observable_counter(
  'system.cpu.time',
  callback: cpu_callback,
  unit: 's',
  description: 'CPU time'
)
```

**ObservableUpDownCounter** - Observes a value that can go up or down (e.g., memory usage, thread count):

```ruby
thread_callback = proc do
  # Return the current thread count
  Thread.list.count
end

meter.create_observable_up_down_counter(
  'process.threads.count',
  callback: thread_callback,
  unit: '1',
  description: 'Current thread count'
)
```

**ObservableGauge** - Observes a point-in-time value (e.g., temperature, current memory usage):

```ruby
memory_callback = proc do
  # Return resident set size in bytes
  memory_kb = `ps -o rss= -p #{Process.pid}`.to_i
  memory_kb * 1024
end

meter.create_observable_gauge(
  'process.memory.usage',
  callback: memory_callback,
  unit: 'By',
  description: 'Current memory usage in bytes'
)
```

</details>

<details>
<ToggleHeading>
## Runtime Metrics
</ToggleHeading>

Ruby does not have a built-in runtime metrics package like Python or Node.js. However, you can collect system and process metrics using observable instruments.

### Create a Runtime Metrics Helper

Create a helper module to collect common runtime metrics:

```ruby:lib/runtime_metrics.rb
module RuntimeMetrics
  def self.setup(meter)
    # Memory usage (returns bytes)
    memory_callback = proc do
      memory_kb = `ps -o rss= -p #{Process.pid}`.to_i
      memory_kb * 1024
    end
    meter.create_observable_gauge(
      'process.memory.usage',
      callback: memory_callback,
      unit: 'By',
      description: 'Process memory usage in bytes'
    )

    # Thread count
    thread_callback = proc { Thread.list.count }
    meter.create_observable_up_down_counter(
      'process.threads.count',
      callback: thread_callback,
      unit: '1',
      description: 'Number of threads in the process'
    )

    # CPU time (user mode)
    cpu_user_callback = proc { Process.times.utime }
    meter.create_observable_counter(
      'process.cpu.time.user',
      callback: cpu_user_callback,
      unit: 's',
      description: 'Process CPU time in user mode'
    )

    # CPU time (system mode)
    cpu_system_callback = proc { Process.times.stime }
    meter.create_observable_counter(
      'process.cpu.time.system',
      callback: cpu_system_callback,
      unit: 's',
      description: 'Process CPU time in system mode'
    )

    # GC stats (Ruby specific)
    gc_count_callback = proc { GC.count }
    meter.create_observable_counter(
      'ruby.gc.count',
      callback: gc_count_callback,
      unit: '1',
      description: 'Number of garbage collections'
    )

    heap_callback = proc { GC.stat[:heap_live_slots] }
    meter.create_observable_gauge(
      'ruby.gc.heap_live_slots',
      callback: heap_callback,
      unit: '1',
      description: 'Number of live objects in the heap'
    )
  end
end
```

### Usage

Enable runtime metrics in your initializer:

```ruby:config/initializers/opentelemetry.rb
require 'opentelemetry/sdk'
require 'opentelemetry-metrics-sdk'
require 'opentelemetry/exporter/otlp_metrics'
require_relative '../../lib/runtime_metrics'

OpenTelemetry::SDK.configure do |c|
  c.service_name = ENV['OTEL_SERVICE_NAME'] || 'my-ruby-service'
end

# Enable runtime metrics
meter = OpenTelemetry.meter_provider.meter('runtime')
RuntimeMetrics.setup(meter)
```

### Exported Metrics

The runtime metrics helper exports the following metrics:

**Process Metrics:**
- `process.memory.usage` - Process memory usage in bytes (gauge)
- `process.threads.count` - Number of threads in the process (up-down counter)
- `process.cpu.time.user` - Process CPU time in user mode (counter)
- `process.cpu.time.system` - Process CPU time in system mode (counter)

**Ruby Runtime Metrics:**
- `ruby.gc.count` - Total number of garbage collections (counter)
- `ruby.gc.heap_live_slots` - Number of live objects in the heap (gauge)

</details>

<details>
<ToggleHeading>
## Setup OpenTelemetry Collector (Optional)
</ToggleHeading>

### What is the OpenTelemetry Collector?

Think of the OTel Collector as a middleman between your app and SigNoz. Instead of your application sending data directly to SigNoz, it sends everything to the Collector first, which then forwards it along.

### Why use it?

- **Cleaning up data** — Filter out noisy metrics you don't care about, or remove sensitive info before it leaves your servers.
- **Keeping your app lightweight** — Let the Collector handle batching, retries, and compression instead of your application code.
- **Adding context automatically** — The Collector can tag your data with useful info like which Kubernetes pod or cloud region it came from.
- **Future flexibility** — Want to send data to multiple backends later? The Collector makes that easy without changing your app.

See [Switch from direct export to Collector](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/switch-to-collector/) for step-by-step instructions to convert your setup.

For more details, see [Why use the OpenTelemetry Collector?](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/why-to-use-collector/) and the [Collector configuration guide](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/configuration/).

</details>

<details>
<ToggleHeading>
## Troubleshooting
</ToggleHeading>

### Metrics not appearing?

1. **Check Environment Variables**: Ensure `OTEL_EXPORTER_OTLP_ENDPOINT` is set to the base URL only:
    - `https://ingest.<region>.signoz.cloud:443`
    - Do **not** append `/v1/metrics`. The Ruby OTLP metrics exporter adds this path automatically.

2. **Check Exporter Protocol**: The Ruby OTLP metrics exporter uses HTTP by default (port 4318). Ensure your endpoint matches.

3. **Verify Metrics are Exported**: The SDK uses a `PeriodicMetricReader` that exports at the interval set by `OTEL_METRIC_EXPORT_INTERVAL`. Ensure you call `shutdown` before your application exits to flush remaining metrics:
    ```ruby
    OpenTelemetry.meter_provider.shutdown
    ```

4. **Enable Debug Logging**: Check for errors in your application logs. You can enable verbose output:
    ```ruby
    OpenTelemetry.logger = Logger.new(STDOUT)
    OpenTelemetry.logger.level = Logger::DEBUG
    ```

5. **Verify Package Installation**: Ensure all required gems are installed:
    ```bash
    bundle list | grep opentelemetry
    ```

### Authentication errors

If you see errors like "Unauthorized" or "403 Forbidden":
- Verify your ingestion key is correct in `OTEL_EXPORTER_OTLP_HEADERS`
- Ensure the header format is exactly: `signoz-ingestion-key=<your-key>` (no extra spaces)
- Check that your ingestion key is active in the SigNoz Cloud dashboard

### "Connection Refused" errors

- If running locally and sending to SigNoz Cloud, check your internet connection and firewall.
- If sending to a self-hosted collector, ensure the collector is running and listening on port 4317 (gRPC) or 4318 (HTTP).

### SSL/TLS errors

If you encounter SSL certificate errors:
- Ensure you're using `https://` in the endpoint URL
- For self-hosted setups with self-signed certificates, you may need to configure the exporter to trust your CA

### Metrics not exported on application exit

Ruby applications may exit before the periodic exporter has a chance to send metrics. Add a shutdown hook:

```ruby
at_exit do
  OpenTelemetry.meter_provider.shutdown
end
```

</details>

## Next Steps

- [Create Dashboards](https://signoz.io/docs/userguide/manage-dashboards/) to visualize your metrics.
- [Set up Alerts](https://signoz.io/docs/setup-alerts-notification/) on your metrics.
- Instrument your Ruby application with [traces](https://signoz.io/docs/instrumentation/opentelemetry-ruby/) for complete observability.
