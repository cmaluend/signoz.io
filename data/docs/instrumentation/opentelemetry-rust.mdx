---
date: 2026-02-05
id: rust

title: Rust OpenTelemetry Instrumentation
description: Send traces from your Rust application to SigNoz using OpenTelemetry
doc_type: howto
---

import GetHelp from '@/components/shared/get-help.md'

This guide shows you how to instrument your Rust application with OpenTelemetry and send traces to SigNoz. Rust requires manual instrumentation since there is no auto-instrumentation agent for compiled languages.

<KeyPointCallout title="Using self-hosted SigNoz?" defaultCollapsed={true}>
Most steps are identical. To adapt this guide, update the endpoint and remove the ingestion key header as shown in [Cloud → Self-Hosted](https://signoz.io/docs/ingestion/cloud-vs-self-hosted/#cloud-to-self-hosted).
</KeyPointCallout>

## Prerequisites

- Rust 1.75 or newer
- Cargo (comes with Rust)
- A SigNoz Cloud account or self-hosted SigNoz instance

Tested with OpenTelemetry Rust SDK v0.28.0.

## Send traces to SigNoz

<Tabs entityName="deployment">
<TabItem value="vm" label="VM" default>

<KeyPointCallout title="What classifies as VM?" defaultCollapsed={true}>
A VM is a virtual computer that runs on physical hardware. This includes:
- **Cloud VMs**: AWS EC2, Google Compute Engine, Azure VMs, DigitalOcean Droplets
- **On-premise VMs**: VMware, VirtualBox, Hyper-V, KVM
- **Bare metal servers**: Physical servers running Linux/Unix directly

Use this section if you're deploying your Rust application directly on a server or VM without containerization.
</KeyPointCallout>

### Step 1. Set environment variables

```bash
export OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443"
export OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>"
export OTEL_SERVICE_NAME="<service-name>"
```

Verify these values:
- `<region>`: Your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint) (`us`, `eu`, or `in`)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`)

### Step 2. Add OpenTelemetry dependencies

Add the following to your `Cargo.toml` under `[dependencies]`:

```toml:Cargo.toml
opentelemetry = { version = "0.28.0", features = ["trace"] }
opentelemetry_sdk = { version = "0.28.0", features = ["trace", "rt-tokio"] }
opentelemetry-otlp = { version = "0.28.0", features = ["grpc-tonic", "trace", "tls-roots"] }
tokio = { version = "1", features = ["full"] }
tonic = { version = "0.12", features = ["tls", "tls-native-roots"] }
```

<Admonition type="info">
The `tls-roots` feature in `opentelemetry-otlp` and `tls-native-roots` in `tonic` are required for sending data to SigNoz Cloud over HTTPS.
</Admonition>

### Step 3. Create the tracer initialization

Add the following imports and function to your `main.rs`:

```rust:src/main.rs
use opentelemetry::trace::{TraceContextExt, Tracer};
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::{SpanExporter, WithTonicConfig};
use opentelemetry_sdk::trace::SdkTracerProvider;
use opentelemetry_sdk::Resource;

fn init_tracer() -> SdkTracerProvider {
    let service_name = std::env::var("OTEL_SERVICE_NAME")
        .unwrap_or_else(|_| "rust-app".to_string());

    // The SDK automatically reads these environment variables:
    // - OTEL_EXPORTER_OTLP_ENDPOINT
    // - OTEL_EXPORTER_OTLP_HEADERS
    // - OTEL_EXPORTER_OTLP_TIMEOUT
    let exporter = SpanExporter::builder()
        .with_tonic()
        .with_tls_config(tonic::transport::ClientTlsConfig::new().with_native_roots())
        .build()
        .expect("Failed to create span exporter");

    // Resource::builder() includes SDK telemetry attributes automatically
    let resource = Resource::builder()
        .with_service_name(service_name)
        .build();

    SdkTracerProvider::builder()
        .with_resource(resource)
        .with_batch_exporter(exporter)
        .build()
}
```

### Step 4. Initialize tracing in your application

Update your `main` function to initialize the tracer:

```rust:src/main.rs
#[tokio::main]
async fn main() {
    // Initialize tracer
    let tracer_provider = init_tracer();
    // Clone required: set_tracer_provider takes ownership, but we need the original for shutdown
    global::set_tracer_provider(tracer_provider.clone());

    let tracer = global::tracer("my_app");

    // Create a span - `cx` is the Context providing access to the current span
    tracer.in_span("my_operation", |cx| {
        let span = cx.span();
        span.set_attribute(KeyValue::new("key", "value"));
        span.add_event("event_name", vec![KeyValue::new("event.attr", "value")]);
        
        // Your application logic here
    });

    // Flush buffered spans and shut down the tracer provider
    tracer_provider.shutdown().expect("Failed to shutdown tracer provider");
}
```

### Step 5. Run your application

```bash
cargo run
```

</TabItem>
<TabItem value="k8s" label="Kubernetes">

### Step 1. Set environment variables in your deployment

Add these environment variables to your Kubernetes deployment manifest:

```yaml
env:
- name: OTEL_EXPORTER_OTLP_ENDPOINT
  value: 'https://ingest.<region>.signoz.cloud:443'
- name: OTEL_EXPORTER_OTLP_HEADERS
  value: 'signoz-ingestion-key=<your-ingestion-key>'
- name: OTEL_SERVICE_NAME
  value: '<service-name>'
```

Verify these values:
- `<region>`: Your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint) (`us`, `eu`, or `in`)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`)

### Step 2. Add OpenTelemetry dependencies

Add the following to your `Cargo.toml` under `[dependencies]`:

```toml:Cargo.toml
opentelemetry = { version = "0.28.0", features = ["trace"] }
opentelemetry_sdk = { version = "0.28.0", features = ["trace", "rt-tokio"] }
opentelemetry-otlp = { version = "0.28.0", features = ["grpc-tonic", "trace", "tls-roots"] }
tokio = { version = "1", features = ["full"] }
tonic = { version = "0.12", features = ["tls", "tls-native-roots"] }
```

### Step 3. Create the tracer initialization

Add the following imports and function to your `main.rs`:

```rust:src/main.rs
use opentelemetry::trace::{TraceContextExt, Tracer};
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::{SpanExporter, WithTonicConfig};
use opentelemetry_sdk::trace::SdkTracerProvider;
use opentelemetry_sdk::Resource;

fn init_tracer() -> SdkTracerProvider {
    let service_name = std::env::var("OTEL_SERVICE_NAME")
        .unwrap_or_else(|_| "rust-app".to_string());

    // The SDK automatically reads these environment variables:
    // - OTEL_EXPORTER_OTLP_ENDPOINT
    // - OTEL_EXPORTER_OTLP_HEADERS
    // - OTEL_EXPORTER_OTLP_TIMEOUT
    let exporter = SpanExporter::builder()
        .with_tonic()
        .with_tls_config(tonic::transport::ClientTlsConfig::new().with_native_roots())
        .build()
        .expect("Failed to create span exporter");

    // Resource::builder() includes SDK telemetry attributes automatically
    let resource = Resource::builder()
        .with_service_name(service_name)
        .build();

    SdkTracerProvider::builder()
        .with_resource(resource)
        .with_batch_exporter(exporter)
        .build()
}
```

### Step 4. Initialize tracing in your application

Update your `main` function to initialize the tracer:

```rust:src/main.rs
#[tokio::main]
async fn main() {
    // Initialize tracer
    let tracer_provider = init_tracer();
    // Clone required: set_tracer_provider takes ownership, but we need the original for shutdown
    global::set_tracer_provider(tracer_provider.clone());

    let tracer = global::tracer("my_app");

    // Create a span - `cx` is the Context providing access to the current span
    tracer.in_span("my_operation", |cx| {
        let span = cx.span();
        span.set_attribute(KeyValue::new("key", "value"));
        span.add_event("event_name", vec![KeyValue::new("event.attr", "value")]);
        
        // Your application logic here
    });

    // Flush buffered spans and shut down the tracer provider
    tracer_provider.shutdown().expect("Failed to shutdown tracer provider");
}
```

### Step 5. Build and deploy

Build your container image and deploy to your Kubernetes cluster.

</TabItem>
<TabItem value="docker" label="Docker">

### Step 1. Set environment variables

Pass environment variables at runtime using `docker run`:

```bash
docker run -e OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443" \
    -e OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>" \
    -e OTEL_SERVICE_NAME="<service-name>" \
    your-image:latest
```

Or add them to your Dockerfile:

```dockerfile:Dockerfile
ENV OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443"
ENV OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>"
ENV OTEL_SERVICE_NAME="<service-name>"
```

Verify these values:
- `<region>`: Your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint) (`us`, `eu`, or `in`)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`)

### Step 2. Add OpenTelemetry dependencies

Add the following to your `Cargo.toml` under `[dependencies]`:

```toml:Cargo.toml
opentelemetry = { version = "0.28.0", features = ["trace"] }
opentelemetry_sdk = { version = "0.28.0", features = ["trace", "rt-tokio"] }
opentelemetry-otlp = { version = "0.28.0", features = ["grpc-tonic", "trace", "tls-roots"] }
tokio = { version = "1", features = ["full"] }
tonic = { version = "0.12", features = ["tls", "tls-native-roots"] }
```

### Step 3. Create the tracer initialization

Add the following imports and function to your `main.rs`:

```rust:src/main.rs
use opentelemetry::trace::{TraceContextExt, Tracer};
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::{SpanExporter, WithTonicConfig};
use opentelemetry_sdk::trace::SdkTracerProvider;
use opentelemetry_sdk::Resource;

fn init_tracer() -> SdkTracerProvider {
    let service_name = std::env::var("OTEL_SERVICE_NAME")
        .unwrap_or_else(|_| "rust-app".to_string());

    // The SDK automatically reads these environment variables:
    // - OTEL_EXPORTER_OTLP_ENDPOINT
    // - OTEL_EXPORTER_OTLP_HEADERS
    // - OTEL_EXPORTER_OTLP_TIMEOUT
    let exporter = SpanExporter::builder()
        .with_tonic()
        .with_tls_config(tonic::transport::ClientTlsConfig::new().with_native_roots())
        .build()
        .expect("Failed to create span exporter");

    // Resource::builder() includes SDK telemetry attributes automatically
    let resource = Resource::builder()
        .with_service_name(service_name)
        .build();

    SdkTracerProvider::builder()
        .with_resource(resource)
        .with_batch_exporter(exporter)
        .build()
}
```

### Step 4. Initialize tracing in your application

Update your `main` function to initialize the tracer:

```rust:src/main.rs
#[tokio::main]
async fn main() {
    // Initialize tracer
    let tracer_provider = init_tracer();
    // Clone required: set_tracer_provider takes ownership, but we need the original for shutdown
    global::set_tracer_provider(tracer_provider.clone());

    let tracer = global::tracer("my_app");

    // Create a span - `cx` is the Context providing access to the current span
    tracer.in_span("my_operation", |cx| {
        let span = cx.span();
        span.set_attribute(KeyValue::new("key", "value"));
        span.add_event("event_name", vec![KeyValue::new("event.attr", "value")]);
        
        // Your application logic here
    });

    // Flush buffered spans and shut down the tracer provider
    tracer_provider.shutdown().expect("Failed to shutdown tracer provider");
}
```

### Step 5. Build and run

```dockerfile:Dockerfile
FROM rust:1.75 AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src
RUN cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY --from=builder /app/target/release/your-app .

CMD ["./your-app"]
```

```bash
docker build -t your-image:latest .
docker run -e OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443" \
    -e OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>" \
    -e OTEL_SERVICE_NAME="<service-name>" \
    your-image:latest
```

</TabItem>
<TabItem value="windows" label="Windows">

### Step 1. Set environment variables (PowerShell)

```powershell
$env:OTEL_EXPORTER_OTLP_ENDPOINT = "https://ingest.<region>.signoz.cloud:443"
$env:OTEL_EXPORTER_OTLP_HEADERS = "signoz-ingestion-key=<your-ingestion-key>"
$env:OTEL_SERVICE_NAME = "<service-name>"
```

Verify these values:
- `<region>`: Your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint) (`us`, `eu`, or `in`)
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
- `<service-name>`: A descriptive name for your service (e.g., `payment-service`)

### Step 2. Add OpenTelemetry dependencies

Add the following to your `Cargo.toml` under `[dependencies]`:

```toml:Cargo.toml
opentelemetry = { version = "0.28.0", features = ["trace"] }
opentelemetry_sdk = { version = "0.28.0", features = ["trace", "rt-tokio"] }
opentelemetry-otlp = { version = "0.28.0", features = ["grpc-tonic", "trace", "tls-roots"] }
tokio = { version = "1", features = ["full"] }
tonic = { version = "0.12", features = ["tls", "tls-native-roots"] }
```

### Step 3. Create the tracer initialization

Add the following imports and function to your `main.rs`:

```rust:src/main.rs
use opentelemetry::trace::{TraceContextExt, Tracer};
use opentelemetry::{global, KeyValue};
use opentelemetry_otlp::{SpanExporter, WithTonicConfig};
use opentelemetry_sdk::trace::SdkTracerProvider;
use opentelemetry_sdk::Resource;

fn init_tracer() -> SdkTracerProvider {
    let service_name = std::env::var("OTEL_SERVICE_NAME")
        .unwrap_or_else(|_| "rust-app".to_string());

    // The SDK automatically reads these environment variables:
    // - OTEL_EXPORTER_OTLP_ENDPOINT
    // - OTEL_EXPORTER_OTLP_HEADERS
    // - OTEL_EXPORTER_OTLP_TIMEOUT
    let exporter = SpanExporter::builder()
        .with_tonic()
        .with_tls_config(tonic::transport::ClientTlsConfig::new().with_native_roots())
        .build()
        .expect("Failed to create span exporter");

    // Resource::builder() includes SDK telemetry attributes automatically
    let resource = Resource::builder()
        .with_service_name(service_name)
        .build();

    SdkTracerProvider::builder()
        .with_resource(resource)
        .with_batch_exporter(exporter)
        .build()
}
```

### Step 4. Initialize tracing in your application

Update your `main` function to initialize the tracer:

```rust:src/main.rs
#[tokio::main]
async fn main() {
    // Initialize tracer
    let tracer_provider = init_tracer();
    // Clone required: set_tracer_provider takes ownership, but we need the original for shutdown
    global::set_tracer_provider(tracer_provider.clone());

    let tracer = global::tracer("my_app");

    // Create a span - `cx` is the Context providing access to the current span
    tracer.in_span("my_operation", |cx| {
        let span = cx.span();
        span.set_attribute(KeyValue::new("key", "value"));
        span.add_event("event_name", vec![KeyValue::new("event.attr", "value")]);
        
        // Your application logic here
    });

    // Flush buffered spans and shut down the tracer provider
    tracer_provider.shutdown().expect("Failed to shutdown tracer provider");
}
```

### Step 5. Run your application

```powershell
cargo run
```

</TabItem>
</Tabs>

## Validate

With your application running, verify traces are being sent to SigNoz:

1. Trigger an action in your app that generates a trace. Execute the instrumented code path a few times.
2. In SigNoz, open the **Services** tab and click **Refresh**. Your application should appear.
3. Go to the **Traces** tab to see your application's traces.

<details>
<ToggleHeading>

## Troubleshooting

</ToggleHeading>

### Why don't traces appear in SigNoz?

**Check environment variables are set:**

```bash
echo $OTEL_EXPORTER_OTLP_ENDPOINT
echo $OTEL_SERVICE_NAME
```

**Verify your ingestion key is correct:**

```bash
echo $OTEL_EXPORTER_OTLP_HEADERS
```

**Check for TLS errors:**

Ensure you have the `tls-roots` feature enabled in `opentelemetry-otlp` for HTTPS endpoints:

```toml
opentelemetry-otlp = { version = "0.28.0", features = ["grpc-tonic", "trace", "tls-roots"] }
```

### Why do OTLP exports fail with `connection refused`?

- **VM**: Verify the endpoint URL and that your firewall allows outbound HTTPS on port 443
- **Kubernetes**: Ensure the endpoint is reachable from within your pod
- **Self-hosted**: Confirm the collector is listening on the expected port (default: 4317 for gRPC)

### Why are spans not being exported?

Ensure you call `tracer_provider.shutdown()` before your application exits. The batch exporter buffers spans and only sends them periodically or on shutdown:

```rust
// At the end of main()
tracer_provider.shutdown().expect("Failed to shutdown tracer provider");
```

### Why do I see `failed to create span exporter` errors?

This usually indicates a dependency version mismatch. Ensure all OpenTelemetry crates use compatible versions:

```toml
opentelemetry = "0.28.0"
opentelemetry_sdk = "0.28.0"
opentelemetry-otlp = "0.28.0"
```

</details>

<details>
<ToggleHeading>

## Setup OpenTelemetry Collector (Optional)

</ToggleHeading>

### What is the OpenTelemetry Collector?

Think of the OTel Collector as a middleman between your app and SigNoz. Instead of your application sending data directly to SigNoz, it sends everything to the Collector first, which then forwards it along.

### Why use it?

- **Cleaning up data** — Filter out noisy traces you don't care about, or remove sensitive info before it leaves your servers.
- **Keeping your app lightweight** — Let the Collector handle batching, retries, and compression instead of your application code.
- **Adding context automatically** — The Collector can tag your data with useful info like which Kubernetes pod or cloud region it came from.
- **Future flexibility** — Want to send data to multiple backends later? The Collector makes that easy without changing your app.

### Using the Collector

When using a collector, update your environment variables to point to the collector endpoint:

```bash
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"
export OTEL_SERVICE_NAME="<service-name>"
# No ingestion key needed when using a collector
```

You'll also need to remove the `tls-roots` feature if connecting over HTTP:

```toml:Cargo.toml
opentelemetry-otlp = { version = "0.28.0", features = ["grpc-tonic", "trace"] }
```

See [Switch from direct export to Collector](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/switch-to-collector/) for step-by-step instructions.

For more details, see [Why use the OpenTelemetry Collector?](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/why-to-use-collector/) and the [Collector configuration guide](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/configuration/).

</details>

## Sample Rust Application

We have included a sample Rust application at <a href="https://github.com/SigNoz/sample-rust-app" target="_blank" rel="noopener noreferrer nofollow">Sample Rust App Github Repo</a>.

## Next steps

- Need to create custom spans or add attributes yourself? Use the [Manual Instrumentation in Rust](https://signoz.io/docs/instrumentation/rust/manual-instrumentation/) guide once the base setup is in place.
- [Set up alerts](https://signoz.io/docs/setup-alerts-notification/) for your Rust application
