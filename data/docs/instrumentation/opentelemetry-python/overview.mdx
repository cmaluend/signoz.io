---
date: 2025-12-11
id: python
tags: [SigNoz Cloud, Self-Host]
title: Python OpenTelemetry Instrumentation
description: Send traces to SigNoz using OpenTelemetry instrumentation for Python frameworks like Django, Flask, FastAPI, and async workers.
doc_type: howto
---

This guide shows you how to instrument your Python application with OpenTelemetry and send traces to SigNoz. The auto-instrumentation approach works with most Python web frameworks and libraries out of the box.

<KeyPointCallout title="Using self-hosted SigNoz?" defaultCollapsed={true}>
Most steps are identical. To adapt this guide, update the endpoint and remove the ingestion key header as shown in [Cloud → Self-Hosted](https://signoz.io/docs/ingestion/cloud-vs-self-hosted/#cloud-to-self-hosted).
</KeyPointCallout>

## Prerequisites

- Python 3.8 or newer
- A SigNoz Cloud account or self-hosted SigNoz instance
- Your application code

## Send traces to SigNoz

<Tabs entityName="deployment">
<TabItem value="vm" label="VM" default>

<KeyPointCallout title="What classifies as VM?" defaultCollapsed={true}>
A VM is a virtual computer that runs on physical hardware. This includes:
- **Cloud VMs**: AWS EC2, Google Compute Engine, Azure VMs, DigitalOcean Droplets
- **On-premise VMs**: VMware, VirtualBox, Hyper-V, KVM
- **Bare metal servers**: Physical servers running Linux/Unix directly

Use this section if you're deploying your Python application directly on a server or VM without containerization.
</KeyPointCallout>

### Step 1. Create a virtual environment

```bash
python3 -m venv .venv
source .venv/bin/activate
```

### Step 2. Install OpenTelemetry dependencies

```bash
pip install opentelemetry-distro==0.43b0
pip install opentelemetry-exporter-otlp==1.22.0
```

### Step 3. Add automatic instrumentation

This command inspects your application's dependencies and installs the relevant instrumentation packages:

```bash
opentelemetry-bootstrap --action=install
```

<Admonition type="info">
Make sure you have installed all your application dependencies before running this command. It will only install instrumentation for packages that are already installed.
</Admonition>

### Step 4. Run your application

```bash
OTEL_RESOURCE_ATTRIBUTES=service.name=<service_name> \
OTEL_EXPORTER_OTLP_ENDPOINT="https://ingest.<region>.signoz.cloud:443" \
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>" \
OTEL_EXPORTER_OTLP_PROTOCOL=grpc \
opentelemetry-instrument <your_run_command>
```

Replace the following:
- `<region>`: Your SigNoz Cloud region (`us`, `eu`, or `in`). See [endpoints](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint).
- `<your-ingestion-key>`: Your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/).
- `<service_name>`: A descriptive name for your service (e.g., `payment-service`).
- `<your_run_command>`: Your application start command (e.g., `python3 app.py` or `flask run`).

<Admonition type="warning">
Don't run your app in reloader/hot-reload mode as it breaks instrumentation. For example, `export FLASK_ENV=development` enables reloader mode which interferes with OpenTelemetry.
</Admonition>

</TabItem>
<TabItem value="k8s" label="Kubernetes">

For Python applications on Kubernetes, you can use:
- **K8s OTel Operator** (recommended) — Auto-injects instrumentation without code changes
- **OTel Collector Agent** — Manual instrumentation with collector handling forwarding

<Tabs entityName="k8s-method">
<TabItem value="k8s-otel-operator" label="K8s OTel Operator" default>

The [OpenTelemetry Operator](https://opentelemetry.io/docs/kubernetes/operator) manages collectors and auto-instrumentation in Kubernetes. It provides two CRDs: `OpenTelemetryCollector` and `Instrumentation`.

### Step 1. Install cert-manager

```bash
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.1/cert-manager.yaml
kubectl wait --for=condition=Available deployments/cert-manager -n cert-manager
```

### Step 2. Install OpenTelemetry Operator

```bash
kubectl apply -f https://github.com/open-telemetry/opentelemetry-operator/releases/download/v0.116.0/opentelemetry-operator.yaml
```

### Step 3. Create the OpenTelemetry Collector instance

Create `otel-collector.yaml`:

```yaml:otel-collector.yaml
apiVersion: opentelemetry.io/v1alpha1
kind: OpenTelemetryCollector
metadata:
  name: otel-collector
spec:
  mode: deployment
  config: |
    receivers:
      otlp:
        protocols:
          grpc:
            endpoint: 0.0.0.0:4317
          http:
            endpoint: 0.0.0.0:4318
    processors:
      batch: {}
      resource/env:
        attributes:
        - key: deployment.environment
          value: prod
          action: upsert
    exporters:
      otlp:
        endpoint: "ingest.<region>.signoz.cloud:443"
        tls:
          insecure: false
        headers:
          "signoz-ingestion-key": "<your-ingestion-key>"
    service:
      pipelines:
        traces:
          receivers: [otlp]
          processors: [batch, resource/env]
          exporters: [otlp]
```

Replace `<region>` and `<your-ingestion-key>` with your SigNoz Cloud values.

```bash
kubectl apply -f otel-collector.yaml
```

### Step 4. Create the Instrumentation instance

Create `instrumentation.yaml`:

```yaml:instrumentation.yaml
apiVersion: opentelemetry.io/v1alpha1
kind: Instrumentation
metadata:
  name: traces-instrumentation
spec:
  exporter:
    endpoint: http://otel-collector-collector:4318
  propagators:
    - tracecontext
    - baggage
    - b3
  sampler:
    type: parentbased_traceidratio
    argument: "1"
  python:
    image: ghcr.io/open-telemetry/opentelemetry-operator/autoinstrumentation-python:latest
```

```bash
kubectl apply -f instrumentation.yaml
```

### Step 5. Add annotations to your deployment

```yaml:deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: python-app
spec:
  selector:
    matchLabels:
      app: python-app
  template:
    metadata:
      labels:
        app: python-app
      annotations:
        instrumentation.opentelemetry.io/inject-python: "true"
        instrumentation.opentelemetry.io/otel-python-platform: "glibc"  # or "musl" for Alpine
        resource.opentelemetry.io/service.name: "python-app"
    spec:
      containers:
      - name: app
        image: python-app:latest
        ports:
        - containerPort: 8080
```

```bash
kubectl apply -f deployment.yaml
```

</TabItem>
<TabItem value="otel-collector-agent" label="OTel Collector Agent">

Install the OTel Collector agent in your cluster first. See [Kubernetes infrastructure metrics](https://signoz.io/docs/tutorial/kubernetes-infra-metrics/) for setup. The collector handles forwarding to SigNoz, so your app doesn't need the ingestion key.

### Step 1. Add OpenTelemetry to requirements.txt

```txt
opentelemetry-distro==0.43b0
opentelemetry-exporter-otlp==1.22.0
```

### Step 2. Update your Dockerfile

```dockerfile
# Install dependencies and auto-instrumentation
RUN pip install --no-cache-dir -r requirements.txt
RUN opentelemetry-bootstrap --action=install

# Set environment variables
ENV OTEL_RESOURCE_ATTRIBUTES=service.name=<service-name>
ENV OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317
ENV OTEL_EXPORTER_OTLP_PROTOCOL=grpc

# Run with instrumentation
CMD ["opentelemetry-instrument", "python", "app.py"]
```

### Step 3. Build and deploy

```bash
docker build -t <your-image-name> .
kubectl apply -f deployment.yaml
```

</TabItem>
</Tabs>

</TabItem>
<TabItem value="windows" label="Windows">

### Step 1. Create a virtual environment

```bash
python3 -m venv .venv
.venv\Scripts\activate
```

### Step 2. Install OpenTelemetry dependencies

```bash
pip install opentelemetry-distro==0.43b0
pip install opentelemetry-exporter-otlp==1.22.0
```

### Step 3. Add automatic instrumentation

```bash
opentelemetry-bootstrap --action=install
```

### Step 4. Set environment variables and run

```powershell
$env:OTEL_RESOURCE_ATTRIBUTES = "service.name=<service_name>"
$env:OTEL_EXPORTER_OTLP_ENDPOINT = "https://ingest.<region>.signoz.cloud:443"
$env:OTEL_EXPORTER_OTLP_HEADERS = "signoz-ingestion-key=<your-ingestion-key>"
$env:OTEL_EXPORTER_OTLP_PROTOCOL = "grpc"
opentelemetry-instrument <your_run_command>
```

Replace `<region>`, `<your-ingestion-key>`, `<service_name>`, and `<your_run_command>` with your values.

</TabItem>
<TabItem value="docker" label="Docker">

### Step 1. Update your Dockerfile

```dockerfile
# Install OpenTelemetry dependencies
RUN pip install opentelemetry-distro==0.43b0 opentelemetry-exporter-otlp==1.22.0

# Install after your requirements.txt
RUN opentelemetry-bootstrap --action=install

# Set environment variables
ENV OTEL_RESOURCE_ATTRIBUTES=service.name=<service-name>
ENV OTEL_EXPORTER_OTLP_ENDPOINT=https://ingest.<region>.signoz.cloud:443
ENV OTEL_EXPORTER_OTLP_HEADERS=signoz-ingestion-key=<your-ingestion-key>
ENV OTEL_EXPORTER_OTLP_PROTOCOL=grpc

# Run with instrumentation
CMD ["opentelemetry-instrument", "python", "app.py"]
```

Replace `<region>`, `<your-ingestion-key>`, and `<service-name>` with your values.

### Step 2. Build and run

```bash
docker build -t <image-name> .
docker run -d -p <host-port>:<container-port> <image-name>
```

</TabItem>
</Tabs>

## Framework-specific guides

For framework-specific optimizations, background workers like Celery, or manual instrumentation, choose your guide below:

<PythonInstrumentationListicle />

## Validate

With your application running, verify traces are being sent to SigNoz:

1. Trigger an action in your app that generates a web request. Hit the endpoint a few times.
2. In SigNoz, open the **Services** tab and click **Refresh**. Your application should appear.
3. Go to the **Traces** tab to see your application's traces.

<details>
<ToggleHeading>

## Running with Gunicorn or uWSGI

</ToggleHeading>

For application servers based on pre-fork models (Gunicorn, uWSGI), you need to add a `post_fork` hook to ensure proper instrumentation.

See the [OpenTelemetry fork process documentation](https://opentelemetry-python.readthedocs.io/en/latest/examples/fork-process-model/README.html) and this [working Gunicorn example](https://github.com/open-telemetry/opentelemetry-python/tree/main/docs/examples/fork-process-model).

</details>

<details>
<ToggleHeading>

## Troubleshooting

</ToggleHeading>

### Spans are not being reported

Enable debug exporter to see trace data in the console:

```bash
OTEL_RESOURCE_ATTRIBUTES=service.name=<service_name> \
OTEL_TRACES_EXPORTER=console \
opentelemetry-instrument <your_run_command>
```

### Application servers (Uvicorn, Hypercorn)

- **Uvicorn** with `--workers` flag is not supported. Workaround: use `gunicorn -k uvicorn.workers.UvicornWorker`.
- **Hypercorn** is not supported. See [this issue](https://github.com/pgjones/hypercorn/issues/215) for updates.

### Hot reload breaks instrumentation

Don't run your app in reloader/hot-reload mode. For Flask, avoid `FLASK_ENV=development` as it enables reloader mode.

### gRPC installation issues

If `grpcio` installation fails, use the HTTP exporter instead:

```bash
pip install opentelemetry-exporter-otlp-proto-http
```

Then set `OTEL_EXPORTER_OTLP_PROTOCOL=http/protobuf`.

</details>

<details>
<ToggleHeading>

## Setup OpenTelemetry Collector (Optional)

</ToggleHeading>

### What is the OpenTelemetry Collector?

Think of the OTel Collector as a middleman between your app and SigNoz. Instead of your application sending data directly to SigNoz, it sends everything to the Collector first, which then forwards it along.

### Why use it?

- **Cleaning up data** — Filter out noisy traces you don't care about, or remove sensitive info before it leaves your servers.
- **Keeping your app lightweight** — Let the Collector handle batching, retries, and compression instead of your application code.
- **Adding context automatically** — The Collector can tag your data with useful info like which Kubernetes pod or cloud region it came from.
- **Future flexibility** — Want to send data to multiple backends later? The Collector makes that easy without changing your app.

See [Switch from direct export to Collector](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/switch-to-collector/) for step-by-step instructions to convert your setup.

For more details, see [Why use the OpenTelemetry Collector?](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/why-to-use-collector/) and the [Collector configuration guide](https://signoz.io/docs/opentelemetry-collection-agents/opentelemetry-collector/configuration/).

</details>

## Next steps

- [Add manual instrumentation](/docs/instrumentation/manual-instrumentation/python/manual-instrumentation) for custom spans and attributes
- [Send logs from Python](/docs/logs-management/send-logs/python-logs-to-signoz/) and correlate with traces
- [Correlate traces with logs](/docs/traces-management/guides/correlate-traces-and-logs/) to accelerate debugging
