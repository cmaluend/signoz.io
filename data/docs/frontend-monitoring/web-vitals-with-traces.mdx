---
date: 2025-11-20
title: Web Vitals Monitoring with OpenTelemetry Traces
id: opentelemetry-web-vitals-traces
description: Set up web vitals monitoring with traces using SigNoz and OpenTelemetry

---

## Overview

This documentation provides a step-by-step guide to setting up web vitals monitoring with OpenTelemetry traces on SigNoz.

<Admonition>
  **Already sending frontend traces?** 
  
  If you've followed the [Sending Traces from your frontend application](https://signoz.io/docs/frontend-monitoring/sending-traces-with-opentelemetry) guide, you can skip Steps 1 and 2 below as your instrumentation file is already set up. Jump straight to [Step 3](#step-3-capture-and-export-web-vitals) to add web vitals capture to your existing setup.
</Admonition>

## Prerequisites

- [SigNoz Cloud](https://signoz.io/teams/) or self-hosted account
- A web application from where you want to send web vitals

## Setup

### Step 1: Install dependencies

<Tabs groupId="web-vitals-dependencies">
  <TabItem value="npm" label="Npm" default>
    ```sh
    npm install web-vitals
    npm install @opentelemetry/api
    npm install @opentelemetry/sdk-trace-web
    npm install @opentelemetry/instrumentation
    npm install @opentelemetry/exporter-trace-otlp-http
    npm install @opentelemetry/context-zone
    npm install @opentelemetry/resources
    npm install ua-parser-js
    ```
  </TabItem>
  <TabItem value="yarn" label="Yarn">
    ```sh
    yarn add web-vitals
    yarn add @opentelemetry/api
    yarn add @opentelemetry/sdk-trace-web
    yarn add @opentelemetry/instrumentation
    yarn add @opentelemetry/exporter-trace-otlp-http
    yarn add @opentelemetry/context-zone
    yarn add @opentelemetry/resources
    yarn add ua-parser-js
    ```
  </TabItem>
</Tabs>

<details>
  <summary> Read more about the dependencies </summary>

- **`web-vitals`**: Core library for measuring and reporting web vitals metrics (LCP, INP, CLS, TTFB, FCP)
- **`@opentelemetry/api`**: Provides the core OpenTelemetry API for creating traces and spans
- **`@opentelemetry/sdk-trace-web`**: Web-specific implementation of OpenTelemetry tracing for browser environments
- **`@opentelemetry/instrumentation`**: Base package for OpenTelemetry instrumentation capabilities
- **`@opentelemetry/exporter-trace-otlp-http`**: Exports traces to OpenTelemetry Protocol (OTLP) over HTTP
- **`@opentelemetry/context-zone`**: Manages context propagation using browser's Zone.js for async operations
- **`@opentelemetry/resources`**: Defines service metadata and attributes for your application
- **`ua-parser-js`**: Parses user agent strings to extract browser, device, and OS information for RUM features
</details>

### Step 2: Create an instrumentation file

The instrumentation file is required to setup the `OTLPTraceExporter` and `WebTracerProvider` which are used to capture web vitals as traces within your application and export them to your collector.

<Tabs entityName="language">
  <TabItem value="ts" label="TypeScript" default>
    ```ts:instrumentation.ts
    import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
    import {
      WebTracerProvider,
      BatchSpanProcessor,
    } from '@opentelemetry/sdk-trace-web';
    import { ZoneContextManager } from '@opentelemetry/context-zone';
    import { resourceFromAttributes } from '@opentelemetry/resources';

    const exporter = new OTLPTraceExporter({
      // For the self-hosted version, please use the collector url instead.
      url: `https://ingest.<INGESTION_REGION>.signoz.cloud:443/v1/traces`,
      headers: {
        // Optional for the self-hosted version
        'signoz-ingestion-key': '<INGESTION_KEY>',
      },
    });

    const provider = new WebTracerProvider({
      resource: resourceFromAttributes({
        'service.name': '<SERVICE_NAME>',
      }),
      spanProcessors: [new BatchSpanProcessor(exporter)],
    });

    provider.register({
      contextManager: new ZoneContextManager(),
    });
    ```

    - Set the `<INGESTION_REGION>` to match your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
    - Replace `<INGESTION_KEY>` with your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
    - `<SERVICE_NAME>` is the name of your service

  </TabItem>
  <TabItem value="js" label="JavaScript">
    ```js:instrumentation.js
    import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
    import {
      WebTracerProvider,
      BatchSpanProcessor,
    } from '@opentelemetry/sdk-trace-web';
    import { ZoneContextManager } from '@opentelemetry/context-zone';
    import { resourceFromAttributes } from '@opentelemetry/resources';

    const exporter = new OTLPTraceExporter({
      // For the self-hosted version, please use the collector url instead.
      url: `https://ingest.<INGESTION_REGION>.signoz.cloud:443/v1/traces`,
      headers: {
        // Optional for the self-hosted version
        'signoz-ingestion-key': '<INGESTION_KEY>',
      },
    });

    const provider = new WebTracerProvider({
      resource: resourceFromAttributes({
        'service.name': '<SERVICE_NAME>',
      }),
      spanProcessors: [new BatchSpanProcessor(exporter)],
    });

    provider.register({
      contextManager: new ZoneContextManager(),
    });
    ```

    - Set the `<INGESTION_REGION>` to match your SigNoz Cloud [region](https://signoz.io/docs/ingestion/signoz-cloud/overview/#endpoint)
    - Replace `<INGESTION_KEY>` with your SigNoz [ingestion key](https://signoz.io/docs/ingestion/signoz-cloud/keys/)
    - `<SERVICE_NAME>` is the name of your service

  </TabItem>
</Tabs>

<Admonition>
  For self-hosted deployments, add the following CORS configuration to your OpenTelemetry Collector config file to allow browser requests from your frontend domain. Also, update the endpoint and remove the ingestion key header as shown in <a href="/docs/ingestion/cloud-vs-self-hosted#cloud-to-self-hosted">Cloud â†’ Self-Hosted</a>.

```yaml:config.yaml
receivers:
  otlp:
    protocols:
      grpc:
        endpoint: 0.0.0.0:4317
      http:
        endpoint: 0.0.0.0:4318
        cors:
          allowed_origins:
            - <YOUR_FRONTEND_URL>
          allowed_headers: ['*']
```

This configures the OTel Collector to export traces to SigNoz Cloud using the OTLP/HTTP protocol. Read more about OTel Collector configuration [here](https://signoz.io/docs/collection-agents/opentelemetry-collector/configuration/).

</Admonition>

### Step 3: Capture and export Web Vitals

Use the `web-vitals` library to capture key performance metrics like CLS, INP, LCP, TTFB, and FCP.
These are captured through callback functions that you define and exported as traces.

<Tabs entityName="language">
  <TabItem value="ts" label="TypeScript" default>
    ```ts:web-vitals.ts
    import { onFCP, onINP, onTTFB, onLCP, onCLS, type Metric } from 'web-vitals';
    import { trace, context, type Context } from '@opentelemetry/api';
    import { hrTime } from '@opentelemetry/core';

    const webVitalsTracer = trace.getTracer('web-vitals-instrumentation');

    let webVitalsContext: Context | null = null;
    let isContextCreated = false;

    function createWebVitalsContext() {
      if (!isContextCreated) {
        const parentSpan = webVitalsTracer.startSpan('web-vitals');
        webVitalsContext = trace.setSpan(context.active(), parentSpan);
        parentSpan.end();
        isContextCreated = true;
      }
      return webVitalsContext;
    }

    function createWebVitalsSpan(metric: Metric) {
      const ctx = createWebVitalsContext();
      if (!ctx) {
        console.warn('Web vitals context not available for:', metric.name);
        return;
      }

      const now = hrTime();
      const webVitalsSpan = webVitalsTracer.startSpan(
        metric.name,
        { startTime: now },
        ctx
      );

      webVitalsSpan.setAttributes({
        'web_vital.name': metric.name,
        'web_vital.id': metric.id,
        'web_vital.navigationType': metric.navigationType,
        'web_vital.delta': metric.delta,
        'web_vital.rating': metric.rating,
        'web_vital.value': metric.value,
        'url.full': window.location.href,
        'page.title': document.title,
      });

      webVitalsSpan.end();
      return webVitalsSpan;
    }

    createWebVitalsContext();

    onFCP(metric => {
      createWebVitalsSpan(metric);
    });

    onINP(metric => {
      createWebVitalsSpan(metric);
    });

    onTTFB(metric => {
      createWebVitalsSpan(metric);
    });

    onLCP(metric => {
      createWebVitalsSpan(metric);
    });

    onCLS(metric => {
      createWebVitalsSpan(metric);
    });
    ```

  </TabItem>
  <TabItem value="js" label="JavaScript">
    ```js:web-vitals.js
    import { onFCP, onINP, onTTFB, onLCP, onCLS } from 'web-vitals';
    import { trace, context } from '@opentelemetry/api';
    import { hrTime } from '@opentelemetry/core';

    const webVitalsTracer = trace.getTracer('web-vitals-instrumentation');

    let webVitalsContext = null;
    let isContextCreated = false;

    function createWebVitalsContext() {
      if (!isContextCreated) {
        const parentSpan = webVitalsTracer.startSpan('web-vitals');
        webVitalsContext = trace.setSpan(context.active(), parentSpan);
        parentSpan.end();
        isContextCreated = true;
      }
      return webVitalsContext;
    }

    function createWebVitalsSpan(metric) {
      const ctx = createWebVitalsContext();
      if (!ctx) {
        console.warn('Web vitals context not available for:', metric.name);
        return;
      }

      const now = hrTime();
      const webVitalsSpan = webVitalsTracer.startSpan(
        metric.name,
        { startTime: now },
        ctx
      );

      webVitalsSpan.setAttributes({
        'web_vital.name': metric.name,
        'web_vital.id': metric.id,
        'web_vital.navigationType': metric.navigationType,
        'web_vital.delta': metric.delta,
        'web_vital.rating': metric.rating,
        'web_vital.value': metric.value,
        'url.full': window.location.href,
        'page.title': document.title,
      });

      webVitalsSpan.end();
      return webVitalsSpan;
    }

    createWebVitalsContext();

    onFCP(metric => {
      createWebVitalsSpan(metric);
    });

    onINP(metric => {
      createWebVitalsSpan(metric);
    });

    onTTFB(metric => {
      createWebVitalsSpan(metric);
    });

    onLCP(metric => {
      createWebVitalsSpan(metric);
    });

    onCLS(metric => {
      createWebVitalsSpan(metric);
    });
    ```

  </TabItem>
</Tabs>

## Validate

The captured web vitals can be viewed in the [Traces Explorer](https://signoz.io/docs/product-features/trace-explorer/). Each `web-vital` trace contains the 5 web vitals as child spans.

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/guides/frontend-monitoring/web-vitals/web-vitals-traces-explorer.webp"
    alt="Web Vitals"
  />
  <figcaption>
    <i>Web Vitals</i>
  </figcaption>
</figure>

### Attaching additional identifiers to your Web Vitals

You can enrich web vitals with additional metadata like browser type, user ID, page URL etc. to enable real user monitoring (RUM)-like insights.

To do so, you need to write a custom implementation of `SpanProcessor` which will intercept all your exported spans and attach additional attributes to them.

<Tabs entityName="language">
  <TabItem value="ts" label="TypeScript" default>
    ```ts:custom-span-processor.ts
    import type { SpanProcessor } from '@opentelemetry/sdk-trace-web';
    import { UAParser } from 'ua-parser-js';

    export const CONSTANTS = {
      USER_ID: 'user.id',
      USER_AGENT_ORIGINAL: 'user_agent.original',
      USER_AGENT_VERSION: 'user_agent.version',
      USER_AGENT_NAME: 'user_agent.name',
    };

    function getBrowserInfo() {
      // You can add your custom browser tracking logic here as well.
      // This example uses the ua-parser-js package.
      const parser = new UAParser();
      const result = parser.getResult();
      return {
        userAgentOriginal: result.ua || '',
        userAgentVersion: result.browser.version || '',
        userAgentName: result.browser.name || '',
      };
    }

    function getUserId() {
      // You can add your custom user ID tracking logic here as well.
      // This example uses localStorage.
      const userId = localStorage.getItem('userId');
      return {
        userId: userId || '',
      };
    }

    const CustomSpanProcessor: SpanProcessor = {
      onStart: span => {
        const userData = getUserId();
        const browserInfo = getBrowserInfo();

        span.setAttribute(CONSTANTS.USER_ID, userData.userId);
        span.setAttribute(
          CONSTANTS.USER_AGENT_ORIGINAL,
          browserInfo.userAgentOriginal
        );
        span.setAttribute(
          CONSTANTS.USER_AGENT_VERSION,
          browserInfo.userAgentVersion
        );
        span.setAttribute(CONSTANTS.USER_AGENT_NAME, browserInfo.userAgentName);
      },
      onEnd: () => Promise.resolve(),
      forceFlush: () => Promise.resolve(),
      shutdown: () => Promise.resolve(),
    };

    export default CustomSpanProcessor;
    ```

  </TabItem>
  <TabItem value="js" label="JavaScript">
    ```js:custom-span-processor.js
    import { UAParser } from 'ua-parser-js';

    export const CONSTANTS = {
      USER_ID: 'user.id',
      USER_AGENT_ORIGINAL: 'user_agent.original',
      USER_AGENT_VERSION: 'user_agent.version',
      USER_AGENT_NAME: 'user_agent.name',
    };

    function getBrowserInfo() {
      // You can add your custom browser tracking logic here as well.
      // This example uses the ua-parser-js package.
      const parser = new UAParser();
      const result = parser.getResult();
      return {
        userAgentOriginal: result.ua || '',
        userAgentVersion: result.browser.version || '',
        userAgentName: result.browser.name || '',
      };
    }

    function getUserId() {
      // You can add your custom user ID tracking logic here as well.
      // This example uses localStorage.
      const userId = localStorage.getItem('userId');
      return {
        userId: userId || '',
      };
    }

    const CustomSpanProcessor = {
      onStart: span => {
        const userData = getUserId();
        const browserInfo = getBrowserInfo();

        span.setAttribute(CONSTANTS.USER_ID, userData.userId);
        span.setAttribute(
          CONSTANTS.USER_AGENT_ORIGINAL,
          browserInfo.userAgentOriginal
        );
        span.setAttribute(
          CONSTANTS.USER_AGENT_VERSION,
          browserInfo.userAgentVersion
        );
        span.setAttribute(CONSTANTS.USER_AGENT_NAME, browserInfo.userAgentName);
      },
      onEnd: () => Promise.resolve(),
      forceFlush: () => Promise.resolve(),
      shutdown: () => Promise.resolve(),
    };

    export default CustomSpanProcessor;
    ```

  </TabItem>
</Tabs>

Update your instrumentation file to include this processor.

```ts
const provider = new WebTracerProvider({
  resource: resourceFromAttributes({
    'service.name': '<SERVICE_NAME>',
  }),
  spanProcessors: [new BatchSpanProcessor(exporter), CustomSpanProcessor],
})
```

Now every span exported will include these additional contextual attributes.

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/guides/frontend-monitoring/web-vitals/web-vital-trace-details.webp"
    alt="Web Vitals with custom attributes"
  />
  <figcaption>
    <i>Web Vitals with custom attributes</i>
  </figcaption>
</figure>

### Setup Dashboard and alerts

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/events/launch-week-1/web-vitals.webp"
    alt="Core Web Vitals Monitoring in SigNoz"
  />
  <figcaption>
    <i>Core Web Vitals Monitoring in SigNoz </i>
  </figcaption>
</figure>

SigNoz charts support thresholds with color coding. For example, the graph below shows three thresholds for `good`, `needs improvement`, and `critical` levels.

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/events/launch-week-1/thresholds-chart.webp"
    alt="Thresholds in SigNoz"
  />
  <figcaption>
    <i>Thresholds provide a visual cue about your application's performance </i>
  </figcaption>
</figure>

### Out of Box Dashboard

You can [import](https://signoz.io/docs/dashboards/import-dashboard/) our out-of-the-box [Dashboard for web vitals monitoring](/docs/dashboards/dashboard-templates/frontend-monitoring/#web-vitals-with-traces)

## Demo Application

We have set up a [Demo React application](https://github.com/SigNoz/frontend-monitoring-examples/tree/main/web-vitals) that demonstrates monitoring Core Web Vitals with traces using OpenTelemetry and sending them to SigNoz.

## Next Steps

- [Sending logs](/docs/frontend-monitoring/sending-logs)
- [Sending metrics](/docs/frontend-monitoring/sending-metrics)
